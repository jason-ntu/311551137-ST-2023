# Problem1

編譯器：gcc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0
平台：docker / Ubuntu 22.04

Disclaimer: The following codes are automatically generated by chatGPT3.

## Heap out-of-bounds read/write

### problematic code
``` c
#include <stdlib.h>

int main()
{
    int *ptr = malloc(10 * sizeof(int));
    ptr[10] = 5;     // out-of-bounds write
    int x = ptr[11]; // out-of-bounds read
    free(ptr);
    return 0;
}
```

### ASan report
```
=================================================================
==5292==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x604000000038 at pc 0x5564aa97e242 bp 0x7fff4b66fc40 sp 0x7fff4b66fc30
WRITE of size 4 at 0x604000000038 thread T0
    #0 0x5564aa97e241 in main (/workspaces/311551137-ST-2023/Lab06/a.out+0x1241)
    #1 0x7f3fdb8a2d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
    #2 0x7f3fdb8a2e3f in __libc_start_main_impl ../csu/libc-start.c:392
    #3 0x5564aa97e124 in _start (/workspaces/311551137-ST-2023/Lab06/a.out+0x1124)

0x604000000038 is located 0 bytes to the right of 40-byte region [0x604000000010,0x604000000038)
allocated by thread T0 here:
    #0 0x7f3fdbb55867 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145
    #1 0x5564aa97e1fe in main (/workspaces/311551137-ST-2023/Lab06/a.out+0x11fe)
    #2 0x7f3fdb8a2d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58

SUMMARY: AddressSanitizer: heap-buffer-overflow (/workspaces/311551137-ST-2023/Lab06/a.out+0x1241) in main
Shadow bytes around the buggy address:
0x0c087fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0c087fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0c087fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0c087fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0c087fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x0c087fff8000: fa fa 00 00 00 00 00[fa]fa fa fa fa fa fa fa fa
0x0c087fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x0c087fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x0c087fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x0c087fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x0c087fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
Addressable:           00
Partially addressable: 01 02 03 04 05 06 07 
Heap left redzone:       fa
Freed heap region:       fd
Stack left redzone:      f1
Stack mid redzone:       f2
Stack right redzone:     f3
Stack after return:      f5
Stack use after scope:   f8
Global redzone:          f9
Global init order:       f6
Poisoned by user:        f7
Container overflow:      fc
Array cookie:            ac
Intra object redzone:    bb
ASan internal:           fe
Left alloca redzone:     ca
Right alloca redzone:    cb
Shadow gap:              cc
==5292==ABORTING
```

### valgrin report
```
==3694== Memcheck, a memory error detector
==3694== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==3694== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==3694== Command: ./a.out
==3694== 
==3694== Invalid write of size 4
==3694==    at 0x10918B: main (in /workspaces/311551137-ST-2023/Lab06/a.out)
==3694==  Address 0x4a8a068 is 0 bytes after a block of size 40 alloc'd
==3694==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==3694==    by 0x10917E: main (in /workspaces/311551137-ST-2023/Lab06/a.out)
==3694== 
==3694== Invalid read of size 4
==3694==    at 0x109195: main (in /workspaces/311551137-ST-2023/Lab06/a.out)
==3694==  Address 0x4a8a06c is 4 bytes after a block of size 40 alloc'd
==3694==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==3694==    by 0x10917E: main (in /workspaces/311551137-ST-2023/Lab06/a.out)
==3694== 
==3694== 
==3694== HEAP SUMMARY:
==3694==     in use at exit: 0 bytes in 0 blocks
==3694==   total heap usage: 1 allocs, 1 frees, 40 bytes allocated
==3694== 
==3694== All heap blocks were freed -- no leaks are possible
==3694== 
==3694== For lists of detected and suppressed errors, rerun with: -s
==3694== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
```

***

## Stack out-of-bounds read/write

### problematic code
``` c
#include <stdio.h>

int main() {
    int arr[5];
    arr[-1] = 1; // out-of-bounds write
    int x = arr[6]; // out-of-bounds read
    printf("%d", x);
    return 0;
}    
```

### ASan report
```
=================================================================
==6010==ERROR: AddressSanitizer: stack-buffer-underflow on address 0x7ffe67e5099c at pc 0x55d51e02531c bp 0x7ffe67e50960 sp 0x7ffe67e50950
WRITE of size 4 at 0x7ffe67e5099c thread T0
    #0 0x55d51e02531b in main (/workspaces/311551137-ST-2023/Lab06/a.out+0x131b)
    #1 0x7f584dfd8d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
    #2 0x7f584dfd8e3f in __libc_start_main_impl ../csu/libc-start.c:392
    #3 0x55d51e025184 in _start (/workspaces/311551137-ST-2023/Lab06/a.out+0x1184)

Address 0x7ffe67e5099c is located in stack of thread T0 at offset 28 in frame
    #0 0x55d51e025258 in main (/workspaces/311551137-ST-2023/Lab06/a.out+0x1258)

This frame has 1 object(s):
    [32, 52) 'arr' (line 4) <== Memory access at offset 28 underflows this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork
    (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-underflow (/workspaces/311551137-ST-2023/Lab06/a.out+0x131b) in main
Shadow bytes around the buggy address:
0x10004cfc20e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x10004cfc20f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x10004cfc2100: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x10004cfc2110: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x10004cfc2120: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x10004cfc2130: f1 f1 f1[f1]00 00 04 f3 f3 f3 f3 f3 00 00 00 00
0x10004cfc2140: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x10004cfc2150: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x10004cfc2160: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x10004cfc2170: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x10004cfc2180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
Addressable:           00
Partially addressable: 01 02 03 04 05 06 07 
Heap left redzone:       fa
Freed heap region:       fd
Stack left redzone:      f1
Stack mid redzone:       f2
Stack right redzone:     f3
Stack after return:      f5
Stack use after scope:   f8
Global redzone:          f9
Global init order:       f6
Poisoned by user:        f7
Container overflow:      fc
Array cookie:            ac
Intra object redzone:    bb
ASan internal:           fe
Left alloca redzone:     ca
Right alloca redzone:    cb
Shadow gap:              cc
==6010==ABORTING
```

### valgrin report
```
==6367== Memcheck, a memory error detector
==6367== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==6367== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==6367== Command: ./a.out
==6367== 
-555920128==6367== 
==6367== HEAP SUMMARY:
==6367==     in use at exit: 0 bytes in 0 blocks
==6367==   total heap usage: 1 allocs, 1 frees, 1,024 bytes allocated
==6367== 
==6367== All heap blocks were freed -- no leaks are possible
==6367== 
==6367== For lists of detected and suppressed errors, rerun with: -s
==6367== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

***

## Global out-of-bounds read/write

### problematic code
``` c
#include <stdio.h>

int arr[5];

int main() {
    arr[-1] = 1; // out-of-bounds write
    int x = arr[6]; // out-of-bounds read
    printf("%d", x);
    return 0;
}
```

### ASan report
```
=================================================================
==6957==ERROR: AddressSanitizer: global-buffer-overflow on address 0x55b26119b0f8 at pc 0x55b26119828b bp 0x7ffcf30b72b0 sp 0x7ffcf30b72a0
READ of size 4 at 0x55b26119b0f8 thread T0
    #0 0x55b26119828a in main (/workspaces/311551137-ST-2023/Lab06/a.out+0x128a)
    #1 0x7f83bc3cdd8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
    #2 0x7f83bc3cde3f in __libc_start_main_impl ../csu/libc-start.c:392
    #3 0x55b261198144 in _start (/workspaces/311551137-ST-2023/Lab06/a.out+0x1144)

0x55b26119b0f8 is located 4 bytes to the right of global variable 'arr' defined in 'main.c:3:5' (0x55b26119b0e0) of size 20
SUMMARY: AddressSanitizer: global-buffer-overflow (/workspaces/311551137-ST-2023/Lab06/a.out+0x128a) in main
Shadow bytes around the buggy address:
0x0ab6cc22b5c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0ab6cc22b5d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0ab6cc22b5e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0ab6cc22b5f0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0ab6cc22b600: 00 00 00 00 00 00 00 00 f9 f9 f9 f9 f9 f9 f9 f9
=>0x0ab6cc22b610: f9 f9 f9 f9 f9 f9 f9 f9 00 00 00 00 00 00 04[f9]
0x0ab6cc22b620: f9 f9 f9 f9 00 00 00 00 00 00 00 00 00 00 00 00
0x0ab6cc22b630: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0ab6cc22b640: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0ab6cc22b650: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0ab6cc22b660: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
Addressable:           00
Partially addressable: 01 02 03 04 05 06 07 
Heap left redzone:       fa
Freed heap region:       fd
Stack left redzone:      f1
Stack mid redzone:       f2
Stack right redzone:     f3
Stack after return:      f5
Stack use after scope:   f8
Global redzone:          f9
Global init order:       f6
Poisoned by user:        f7
Container overflow:      fc
Array cookie:            ac
Intra object redzone:    bb
ASan internal:           fe
Left alloca redzone:     ca
Right alloca redzone:    cb
Shadow gap:              cc
==6957==ABORTING
```

### valgrin report
```
==7080== Memcheck, a memory error detector
==7080== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==7080== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==7080== Command: ./a.out
==7080== 
0==7080== 
==7080== HEAP SUMMARY:
==7080==     in use at exit: 0 bytes in 0 blocks
==7080==   total heap usage: 1 allocs, 1 frees, 1,024 bytes allocated
==7080== 
==7080== All heap blocks were freed -- no leaks are possible
==7080== 
==7080== For lists of detected and suppressed errors, rerun with: -s
==7080== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

***

## Use-after-free

### problematic code
``` c
#include <stdlib.h>

int main() {
    int *ptr = malloc(10 * sizeof(int));
    free(ptr);
    int x = ptr[0]; // use-after-free read
    ptr[0] = 5; // use-after-free write
    return 0;
}      
```

### ASan report
```
=================================================================
==7284==ERROR: AddressSanitizer: heap-use-after-free on address 0x604000000010 at pc 0x55cf6f77a226 bp 0x7ffe1739e100 sp 0x7ffe1739e0f0
READ of size 4 at 0x604000000010 thread T0
    #0 0x55cf6f77a225 in main (/workspaces/311551137-ST-2023/Lab06/a.out+0x1225)
    #1 0x7f4d1a0d7d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
    #2 0x7f4d1a0d7e3f in __libc_start_main_impl ../csu/libc-start.c:392
    #3 0x55cf6f77a104 in _start (/workspaces/311551137-ST-2023/Lab06/a.out+0x1104)

0x604000000010 is located 0 bytes inside of 40-byte region [0x604000000010,0x604000000038)
freed by thread T0 here:
    #0 0x7f4d1a38a517 in __interceptor_free ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:127
    #1 0x55cf6f77a1ee in main (/workspaces/311551137-ST-2023/Lab06/a.out+0x11ee)
    #2 0x7f4d1a0d7d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58

previously allocated by thread T0 here:
    #0 0x7f4d1a38a867 in __interceptor_malloc ../../../../src/libsanitizer/asan/asan_malloc_linux.cpp:145
    #1 0x55cf6f77a1de in main (/workspaces/311551137-ST-2023/Lab06/a.out+0x11de)
    #2 0x7f4d1a0d7d8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58

SUMMARY: AddressSanitizer: heap-use-after-free (/workspaces/311551137-ST-2023/Lab06/a.out+0x1225) in main
Shadow bytes around the buggy address:
0x0c087fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0c087fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0c087fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0c087fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0c087fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x0c087fff8000: fa fa[fd]fd fd fd fd fa fa fa fa fa fa fa fa fa
0x0c087fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x0c087fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x0c087fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x0c087fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x0c087fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
Addressable:           00
Partially addressable: 01 02 03 04 05 06 07 
Heap left redzone:       fa
Freed heap region:       fd
Stack left redzone:      f1
Stack mid redzone:       f2
Stack right redzone:     f3
Stack after return:      f5
Stack use after scope:   f8
Global redzone:          f9
Global init order:       f6
Poisoned by user:        f7
Container overflow:      fc
Array cookie:            ac
Intra object redzone:    bb
ASan internal:           fe
Left alloca redzone:     ca
Right alloca redzone:    cb
Shadow gap:              cc
==7284==ABORTING
```

### valgrin report
```
==7418== Memcheck, a memory error detector
==7418== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==7418== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==7418== Command: ./a.out
==7418== 
==7418== Invalid read of size 4
==7418==    at 0x109193: main (in /workspaces/311551137-ST-2023/Lab06/a.out)
==7418==  Address 0x4a8a040 is 0 bytes inside a block of size 40 free'd
==7418==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==7418==    by 0x10918E: main (in /workspaces/311551137-ST-2023/Lab06/a.out)
==7418==  Block was alloc'd at
==7418==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==7418==    by 0x10917E: main (in /workspaces/311551137-ST-2023/Lab06/a.out)
==7418== 
==7418== Invalid write of size 4
==7418==    at 0x10919C: main (in /workspaces/311551137-ST-2023/Lab06/a.out)
==7418==  Address 0x4a8a040 is 0 bytes inside a block of size 40 free'd
==7418==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==7418==    by 0x10918E: main (in /workspaces/311551137-ST-2023/Lab06/a.out)
==7418==  Block was alloc'd at
==7418==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==7418==    by 0x10917E: main (in /workspaces/311551137-ST-2023/Lab06/a.out)
==7418== 
==7418== 
==7418== HEAP SUMMARY:
==7418==     in use at exit: 0 bytes in 0 blocks
==7418==   total heap usage: 1 allocs, 1 frees, 40 bytes allocated
==7418== 
==7418== All heap blocks were freed -- no leaks are possible
==7418== 
==7418== For lists of detected and suppressed errors, rerun with: -s
==7418== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
```

***

## Use-after-return

### problematic code
``` c
#include <stdio.h>

int *get_ptr() {
    int x = 5;
    return &x; // return pointer to local variable
}

int main() {
    int *ptr = get_ptr();
    int x = *ptr; // use-after-return read
    return 0;
}
```

### ASan report
```
AddressSanitizer:DEADLYSIGNAL
=================================================================
==8684==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000 (pc 0x561c1a81234c bp 0x7ffd3e53a010 sp 0x7ffd3e53a000 T0)
==8684==The signal is caused by a READ memory access.
==8684==Hint: address points to the zero page.
    #0 0x561c1a81234c in main (/workspaces/311551137-ST-2023/Lab06/a.out+0x134c)
    #1 0x7f814315dd8f in __libc_start_call_main ../sysdeps/nptl/libc_start_call_main.h:58
    #2 0x7f814315de3f in __libc_start_main_impl ../csu/libc-start.c:392
    #3 0x561c1a812124 in _start (/workspaces/311551137-ST-2023/Lab06/a.out+0x1124)

AddressSanitizer can not provide additional info.
SUMMARY: AddressSanitizer: SEGV (/workspaces/311551137-ST-2023/Lab06/a.out+0x134c) in main
==8684==ABORTING

```

### valgrin report
```
==9171== Memcheck, a memory error detector
==9171== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==9171== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==9171== Command: ./a.out
==9171== 
==9171== Invalid read of size 4
==9171==    at 0x1091A4: main (in /workspaces/311551137-ST-2023/Lab06/a.out)
==9171==  Address 0x0 is not stack'd, malloc'd or (recently) free'd
==9171== 
==9171== 
==9171== Process terminating with default action of signal 11 (SIGSEGV)
==9171==  Access not within mapped region at address 0x0
==9171==    at 0x1091A4: main (in /workspaces/311551137-ST-2023/Lab06/a.out)
==9171==  If you believe this happened as a result of a stack
==9171==  overflow in your program's main thread (unlikely but
==9171==  possible), you can try to increase the size of the
==9171==  main thread stack using the --main-stacksize= flag.
==9171==  The main thread stack size used in this run was 8388608.
==9171== 
==9171== HEAP SUMMARY:
==9171==     in use at exit: 0 bytes in 0 blocks
==9171==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
==9171== 
==9171== All heap blocks were freed -- no leaks are possible
==9171== 
==9171== For lists of detected and suppressed errors, rerun with: -s
==9171== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
Segmentation fault
```

|                      | Valgrind | ASan |
|:--------------------:|:--------:|:----:|
| Heap out-of-bounds   |     O    |   O  |
| Stack out-of-bounds  |     X    |   O  |
| Global out-of-bounds |     X    |   O  |
| Use-after-free       |     O    |   O  |
| Use-after-return     |     O    |   ?  |

In the case of Use-after-return, ASan results cannot be shown due to the compiling error.



# Problem2
寫一個簡單程式 with ASan，Stack buffer overflow 剛好越過 redzone(並沒有 對 redzone 做讀寫)，並說明 ASan 能否找的出來?

程式如下
``` c
#include <stdio.h>

int main() {
  int arr[4];
  arr[8] = 1;
  printf("%d\n", arr[8]);
  return 0;
}
```

結果如下
```
gcc -fsanitize=address problem2.c
./a.out
1
```

陣列長度為 4 時，redzone 為 4 bytes，若直接存取超過 redzone 範圍則 ASan 無法偵測出來